#!/bin/bash

source ~/.userfunctions


#----------------------------------------------
printUsage()
{
cat << %%USAGE%%
     Usage: $(basename ${0}) <-h|--help>
            $(basename ${0}) [-xprj1[,prj2,...]] <-l|--list> 
            $(basename ${0}) [-xprj1[,prj2,...]] <-s|--stash> message
            $(basename ${0}) [-xprj1[,prj2,...]] <-p|--pop> [stashId]
            $(basename ${0}) [-xprj1[,prj2,...]] <-a|--apply> [stashId]
            $(basename ${0}) [-xprj1[,prj2,...]] <-d|--drop> [stashId]

    Description:
       Manage (push/pop/etc.) stashes for all checked-out products.

    Options:
       -h
       --help
             Print this help message and exit.

       -xprj1,prj2,...
       --exclude prj1,prj2,...
             The listed projects will be excluded.

       -l
       --list
             Lists the number of stashes each project has.

       -s
       --stash 
             Stash the working state of each project that has local changes.

       -p [stashId]
       --pop [stashId]
             Remove the stashed state with given id and apply it on top
	     of the current working tree for each project. If no stashId is
	     provided stash@{0} is assumed.

       -a [stashId]
       --apply [stashId]
             Like pop, but do not remove the state from the stash list.

%%USAGE%%
}


#----------------------------------------------
listStashes()
{
    local lStashCount=$(git stash list | wc -l)

    # If no stash, return without printing anything
    if [[ ${lStashCount} -eq 0 ]]; then
	return 0
    fi
    
    # Print the number of stashes
    local lEnding=""
    if [[ ${lStashCount} -gt 1 ]]; then
	lEnding="es"
    fi
    printf "%d stash%s" ${lStashCount} ${lEnding}
}

#----------------------------------------------
stashChanges()
{
    local lOutput=$(git stash save $@)
    if [[ -z $(echo $lOutput | grep '^No') ]]; then
	printf "%s" "Stashed changes"
    fi
    
}

#----------------------------------------------
doStashCommand()
{
    local lCommand=${1}
    shift

    local lOutput=$(git stash ${lCommand} $@ 2>&1)
    local lSuccess=$?
    if [[ ${lSuccess} -ne 0 ]]; then
	local lLogFile=git.stash.${lCommand}.log
	cat "${lOutput}" > lLogFile
	printf "Failed (see %s)" "${lLogFile}"
    elif [[ -z $(echo $lOutput | grep '^No') ]]; then
	printf "Done"
    fi
}

#----------------------------------------------
popStash()
{
    doStashCommand pop $@
    return 0

    local lOutput=$(git stash pop $@)
    if [[ -z $(echo $lOutput | grep '^No') ]]; then
	printf "%s" "$(echo "${lOutput}" | grep Dropped)"
    fi
}

#----------------------------------------------
applyStash()
{
    doStashCommand apply $@
    return 0

    local lOutput=$(git stash apply $@ 2>&1)
    local lSuccess=$?
    if [[ ${lSuccess} -ne 0 ]]; then
	local lLogFile=git.stash.apply.log
	cat "${lOutput}" > lLogFile
	printf "Failed (see %s)" "${lLogFile}"
    elif [[ -z $(echo $lOutput | grep '^No') ]]; then
	printf "Done"
    fi
}

#----------------------------------------------
dropStash()
{
    doStashCommand drop $@
    return 0

    local lOutput=$(git stash drop $@ 2>&1)
    local lSuccess=$?
    if [[ ${lSuccess} -ne 0 ]]; then
	local lLogFile=git.stash.drop.log
	cat "${lOutput}" > lLogFile
	printf "Failed (see %s)" "${lLogFile}"
    elif [[ -z $(echo $lOutput | grep '^No') ]]; then
	printf "Done"
    fi
}

#----------------------------------------------
# Main script
#----------------------------------------------
ARGS=$(getopt -o hx:ls:p::a::d:: -l "help,exclude:,list,stash:,pop::,apply::,drop::" -n "$(basename ${0})" -- "$@")

# If wrong arguments, print usage and exit
if [[ $? -ne 0 ]]; then
    printUsage
    exit 1;
fi

eval set -- "$ARGS"

# Default task
task='listStashes'

## Parse options
toExclude=""
while true; do
    case ${1} in
	-h|--help)
	    printUsage
	    exit 0
	    ;;
	-x|--exclude)
	    toExclude="${toExclude},""${2},"
	    shift 2
	    ;;
	-s|--stash)
	    task='stashChanges'
	    arguments=${2}
	    shift 2
	    ;;
	-p|--pop)
	    task='popStash'
	    arguments=${2}
	    shift 2
	    ;;
	-a|--apply)
	    task='applyStash'
	    arguments=${2}
	    shift 2
	    ;;
	-d|--drop)
	    task='dropStash'
	    arguments=${2}
	    shift 2
	    ;;
	-l|--list)
	    task='listStashes'
	    shift
	    ;;
	--)
	    shift
	    break
	    ;;
	"")
	    # This is necessary for processing missing optional arguments 
	    shift
	    ;;
    esac
done


gitDirs=$(listRepos)
alignSize=$(getAlignSize ${gitDirs})

if  [[ ${task} == 'dropStash' ]]; then
    getAnswer "About to drop stash $@ (cannot be undone). Continue?" || exit 0
fi

for d in ${gitDirs}; do
    cd ${d}

    output=$(${task} ${arguments} $@ 2>&1)

    n=$(( alignSize - ${#d} ))
    printf "%s%${n}s: %s\n" ${d} "" "${output}"
    
    cd ->/dev/null
done
