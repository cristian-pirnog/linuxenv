#!/bin/bash

source ~/.userfunctions

#----------------------------------------------
printUsage()
{
    cat << %%USAGE%%

    Usage: $(basename $0) [-h] 
           $(basename $0) [-f|-s] [-D TAG] [--source dirName] [--target dirName] [--branch name] [--project name] --debugLiveFramework <Debug|Release> [all|clean|fresh] [install]
	   

    Description:
       Builds the code using CMake configurations.

       -h
       --help
             print this help message and exit

    Options:

       -f
       --force
             Same as -s.             

       -s
       --script
             Run in script-mode, i.e. don\'t ask for confirmation.

       -D TAG
             Passes the given tag to CMake via a define (-D) option. Multiple
	     options result in appending the given tags.
	     Currently, the following defines will have an efect:
	          DEBUG_SERIALIZATION - enables debugging of the binary serialization
		  DEBUG_LIVE_FRAMEWORK - enables debugging of the live framework
	     IMPORTANT: When using this option, one should make sure that the code 
	     is built fresh.

       --source dirName
             Runs cmake for the given directory. If not specified, 
	     it defaults to the directory above the current.

       --target dirName
             Write the build output to the given directory. If not specified, 
	     it defaults to the current directory.

       --branch name
             (Only when --target is specified) append the given branch
	     name to the target dirName. Defaults to the current branch 
	     of the project.

       --project name
             (Only when --target is specified) append the given project
	     name to the target dirName.

       <x|y>:  one of the arguments in the brackets must be provided

       [x|y]:  optional argument; if none provided, defaults to the first
	       value in the list (i.e. x).

%%USAGE%%
}

#----------------------------------------------
wafBuild()
{
    COMPILER=g++-4.8.2
    waf clean
    CXX=${COMPILER} waf configure build install $@
}


#----------------------------------------------
cmakeBuild()
{
    local lBuildDir=${1}
    local lBuildType=${2}
    local lBranchName=${3}
    local lLibraryType=${4}
    local lCodeDir=${5}
    local lOption=${6}
    local lCmakeOptions=${7}
    shift 7
    
    if [[ ${lCmakeOptions} == 'none' ]]; then
    lCmakeOptions=''
    fi

    if [[ ! -d ${lBuildDir} ]]; then
	mkdir -p ${lBuildDir} || exit 1
    fi
    
    cd ${lBuildDir}
    
    printf "Running cmake...\n\n"
    cmake -DCMAKE_INSTALL_PREFIX=${HOME}/code ${lCmakeOptions} ${lCodeDir} -DCMAKE_LIBRARY_TYPE=${lLibraryType} -DBUILD_OUTPUT_DIR=$(pwd) -DPROJECT_BRANCH=${lBranchName} -DCMAKE_BUILD_TYPE=${buildType}|| return 1

    printf "\n\nRunning make $s...\n\n" ${lOption}
    make ${lOption} ${moreLOptions} $*
}


#----------------------------------------------
# Main script
#----------------------------------------------

if [[ $# -lt 1 ]]; then
    printUsage
    exit 1
fi

ARGS=$(getopt -o hfj::c:sD: -l "help,force,client:,source:,target:,branch:,project:,script,static,shared" -n "build" -- "$@")

# If wrong arguments, print usage and exit
if [[ $? -ne 0 ]]; then
    printUsage
    exit 1;
fi

eval set -- "$ARGS"

#
libraryType=SHARED
scriptMode=0
buildDirRoot="."
sourceDir=$(pwd)
compilerFlags=''
while true; do
    case ${1} in
	-h|--help)
	    printUsage
	    exit 0
	    ;;
	-f|--force|-s|--script)
	    scriptMode=1
	    shift
	    ;;
	-j)
	    moreOptions="${moreOptions} -j"
	    if [[ -n ${2} ]]; then
		moreOptions="${moreOptions}${2}"
		shift
	    fi
	    shift
	    ;;
	-c|--client)
	    clientOption="--client ${2}"
	    shift 2
	    ;;
	--source)
	    sourceDir="${2}"
	    shift 2
	    ;;
	--target)
	    buildDirRoot="${2}"
	    shift 2
	    ;;
	--branch)
	    branchName=$(echo ${2} | replace '\.' '/')
	    shift 2
	    ;;
	--project)
	    projectName=$(echo ${2} | replace '\.' '/')
	    shift 2
	    ;;
	-D)
            compilerFlags=${compilerFlags}" -D${2}=on"
            shift 2
            ;;
#	--static)
#	    libraryType=STATIC
#	    shift
#	    ;;
#	--shared)
#	    libraryType=SHARED
#	    shift
#	    ;;
	--)
	    shift
	    break
	    ;;
	"")
	    # This is necessary for processing missing optional arguments 
	    shift
	    ;;
	*)
	    echo "Option ${1} accepted but not handled. Please report this as a bug."
	    exit 1
    esac
done

if [[ $# -lt 1 ]]; then
    printUsage
    exit 1
fi

buildType=${1}
shift
option=${1}
shift

if [[ -z ${compilerFlags} ]]; then
    compilerFlags='none'
fi

if [[ ${buildDirRoot} != "." ]]; then
    buildDir=${branchName}/${buildType}/${projectName}
else
    buildDir=${buildType}
fi

case ${option} in
    "clean"|"fresh")
	remove=1
	if [[ ${scriptMode} -eq 0 ]]; then
	    getAnswer "About to remove directory ${buildDir}. Continue?" || remove=0
	fi

	if [[ ${remove} -eq 1 ]]; then
	    if [[ -f wscript ]]; then
		waf configure distclean -o ${buildDirRoot}/${buildDir}
	    else
		rm -rf ${buildDir}
	    fi
	fi

	if [[ ${option} == "clean" ]]; then 
	    exit 0
	else
	    option='all'
	fi
        ;;
    "")
	option="all"
	;;
esac




# If there's a wscript file in the current dir, runn a waf build
if [[ -f wscript ]]; then
    wafBuild ${clientOption} --buildType ${buildType} --branch ${branchName} --libDirRoot ${buildDirRoot} -o ${buildDirRoot}/${buildDir}
else
    # Check for a CMakeList.txt file
    if [[ ! -f "CMakeLists.txt" ]]; then
	echo "No file CMakeLists.txt found in the current directory ($(pwd)). Aborting."
	exit 1
    fi

    mkdir -p ${buildDirRoot} || exit 1
    cd ${buildDirRoot} || exit 1
    cmakeBuild ${buildDir} ${buildType} ${branchName} ${libraryType} ${sourceDir} ${option} ${compilerFlags} ${moreOptions} $@
fi
