#!/bin/bash

source ~/.userfunctions

#----------------------------------------------
printUsage()
{
cat << %%USAGE%%
     Usage: $(basename ${0}) [-h]
            $(basename ${0}) [-xprj1[,prj2,...]] <-c|--create>  branchName
            $(basename ${0}) [-xprj1[,prj2,...]] <-d|--delete>  branchName
            $(basename ${0}) [-xprj1[,prj2,...]] <-s|--switch>  branchName
            $(basename ${0}) [-xprj1[,prj2,...]] <-l|--list> [all]

    Description:
       Creates/deletes a branch for all checked-out products.

    Options:
       -h
       --help
             Print this help message and exit.

       -xprj1,prj2,...
       --exclude prj1,prj2,...
             The listed projects will be excluded.

       -c branchName
       --create branchName
             Create branches branchName (one for each project). 

       -d branchName
       --delete branchName
             Delete branches branchName (one for each project).

       -s branchName
       --switch branchName
             Switch to branchName for all projects.

       -l [all]
       --list [all]
             List the current branch for each project. If option 'all' is
	     provided, lists all the branches for each project.

       <x|y>:
             One of the arguments in the brackets must be provided

%%USAGE%%
}

#----------------------------------------------
listBranches()
{
    local lAll="${1}"

    local lGitDirs=$(listRepos)
    local lAlignSize=$(getAlignSize ${lGitDirs})

    if [[ ${lAll} = 'all' ]]; then
	printf "All branches: \n"
    else
	printf "\nCurrent active branches \n-----------------------\n"
    fi

    for p in ${lGitDirs}; do
	cd ${p}
	if [[ ${lAll} = 'all' ]]; then
	    printf "Project %s: \n%s\n\n" "${p}" "$(git branch --list)"
	else
	    n=$(( lAlignSize - ${#p} ))
	    printf "Project %s%${n}s: %s\n" "${p}"  "" "$(git branch --list | grep '^*' | awk '{print $NF}')"
	fi
	cd ->/dev/null
    done
}

#----------------------------------------------
createBranch()
{
    local lBranch=${1}

    if [[ -n $(git branch --list | grep -v Project | grep ${lBranch}) ]]; then
	echo "A branch '${lBranch}' already exists. Skipping"
	return 1
    fi

    git branch ${lBranch}
    git checkout ${lBranch}
}

#----------------------------------------------
forceDeleteBranch()
{
    git branch -D ${1}
}

#----------------------------------------------
deleteBranch()
{
    git branch -d ${1}
}

#----------------------------------------------
switchBranch()
{
    git checkout ${1}
}

#----------------------------------------------
# Main script
#----------------------------------------------
ARGS=$(getopt -o hx:c:d:D:s:l -l "help,exclude:,create:,delete:,DELETE:,switch:,list::" -n "$(basename ${0})" -- "$@")

# If wrong arguments, print usage and exit
if [[ $? -ne 0 ]]; then
    printUsage
    exit 1;
fi

eval set -- "$ARGS"

# Go th the code directory
if [[ $(pwd) != "${HOME}/code" ]]; then
    cd ~/code
fi

## Parse options
toExclude=""
while true; do
    case ${1} in
	-h|--help)
	    printUsage
	    exit 0
	    ;;
	-x|--exclude)
	    toExclude="${toExclude},""${2},"
	    shift 2
	    ;;
	-c|--create)
	    task='createBranch'
	    branchName=${2}
	    shift 2
	    ;;
	-d|--delete)
	    task='deleteBranch'
	    branchName=${2}
	    shift 2
	    ;;
	-D|--DELETE)
	    task='forceDeleteBranch'
	    branchName=${2}
	    shift 2
	    ;;
	-s|--switch)
	    task='switchBranch'
	    branchName=${2}
	    shift 2
	    ;;
	-l|--list)
	    shift
	    listBranches ${2}
	    exit 0
	    ;;
	--)
	    shift
	    break
	    ;;
	"")
	    # This is necessary for processing missing optional arguments 
	    shift
	    ;;
    esac
done

# If no task specified, default to list
if [[ -z ${task} ]]; then
    listBranches
    exit 0
fi

gitDirs=$(listRepos)
alignSize=$(getAlignSize ${gitDirs})

for d in ${gitDirs}; do
    if [[ -n $(echo ${toExclude} | grep ",${d},") ]]; then
	echo "Skipping project ${d}"
	continue
    fi
    cd ${d}
    n=$(( alignSize - ${#d} ))
    output=$(${task} ${branchName} 2>&1)
    printf "%s%${n}s: %s\n" "$(pwd)" "" "${output}"
    cd ->/dev/null
done
