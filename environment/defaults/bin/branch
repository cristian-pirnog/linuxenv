#!/bin/bash

source ~/.userfunctions

#----------------------------------------------
printUsage()
{
cat << %%USAGE%%
     Usage: $(basename ${0}) [-h]
            $(basename ${0}) [-xprj1[,prj2,...]] <-c|--create>  branchName
            $(basename ${0}) [-xprj1[,prj2,...]] <-d|--delete>  branchName
            $(basename ${0}) [-xprj1[,prj2,...]] <-D|--DELETE>  branchName
            $(basename ${0}) [-xprj1[,prj2,...]] <-f|--fetch> 
            $(basename ${0}) [-xprj1[,prj2,...]] <-s|--switch>  branchName
	    $(basename ${0}) [-xprj1[,prj2,...]] <-t|--track>   [branchName]
            $(basename ${0}) [-xprj1[,prj2,...]] <-m|--merge>   fromBranch toBranch 
            $(basename ${0}) [-xprj1[,prj2,...]] <-l|--list> [s] [all]

    Description:
       Manage (create/delete/switch/etc.) branches for all checked-out products.

    Options:
       -h
       --help
             Print this help message and exit.

       -xprj1,prj2,...
       --exclude prj1,prj2,...
             The listed projects will be excluded.

       -c branchName
       --create branchName
             Create branches branchName (one for each project). 

       -d branchName
       --delete branchName
             Delete branches branchName (one for each project).

       -D branchName
       --DELETE branchName
             Deletes branches branchName (one for each project) irrespective 
	     of their merged status.

       -f 
       --fetch
             Performs git fetch for each project, in order to update the info
	     about branches that exist on the remote server.

       -s branchName
       --switch branchName
             Switch to branchName for all projects.

       -t branchName
       --track branchName
             Set-up given branch to be tracked on the remote server.

       -m fromBranch [toBranch]
       --merge fromBranch [toBranch]
             Merge the changes in fromBranch to toBranch

       -l [all]
       --list [s] [all]
             List the current branch for each project. 

	     If option 's' is provided, the output will be formatted for use 
	     in scripts (i.e. no header, footer).

	     If option 'all' is provided, lists all the branches for each 
	     project.

       <x|y>:
             One of the arguments in the brackets must be provided

%%USAGE%%
}

#----------------------------------------------
printCurrentBranch()
{
    branch -l s | awk '{print $NF}' | sort | uniq
}


#----------------------------------------------
printProjectsForBranch()
{
    local lAll=${1}
    listBranches ${lAll} | sed -n "/Project/,/${lBranch}/p" | grep Project | replace Project ""
}


#----------------------------------------------
printActiveBranches()
{
    listBranches | grep Project | awk '{print $NF}' | sort | uniq
}

#----------------------------------------------
checkLocalChanges()
{
    local lActivity=${1}
    local lBranchesWithChanges=$(stall -s)
    if [[ -n ${lBranchesWithChanges} ]]; then
	printf "\nThe following branches have local changes\n"
	echo "${lBranchesWithChanges}"
	printf "\nCommit/stash changes before ${lActivity}ing.\n"
	return 1
    fi
    return 0

}

#----------------------------------------------
listBranches()
{
    local lOption="${1}"

    local lGitDirs=$(listRepos)
    local lAlignSize=$(getAlignSize ${lGitDirs})

    local lPrefix="Project "
    local lSep=":"
    if [[ ${lOption} = 'all' ]]; then
	printf "All branches: \n"
    elif [[ ${lOption} == 's' ]]; then
	lPrefix=""
	lSep=""
    else
	printf "\nCurrent active branches \n-----------------------\n"
    fi

    for p in ${lGitDirs}; do
	cd ${p}
	if [[ ${lOption} = 'all' ]]; then
	    printf "Project %s: \n%s\n\n" "${p}" "$(git branch --list)"
	else
	    n=$(( lAlignSize - ${#p} +1 ))
	    printf "%s%s%s%${n}s %s\n" "${lPrefix}" "${p}" "" "${lSep}" "$(git branch --list | grep '^*' | awk '{print $NF}')"
	fi
	cd ->/dev/null
    done
}

#----------------------------------------------
check_createBranch()
{
    local lBranch=${1}

    if [[ -n $(listBranches all | grep -v Project | grep " ${lBranch}") ]]; then
	printf "Branch '${lBranch}' already exists in the following projects.\n"
	printProjectsForBranch all
	return 1
    fi

    return 0
}

#----------------------------------------------
createBranch()
{
    local lBranch=${1}

    git branch ${lBranch}
    git checkout ${lBranch}
}

#----------------------------------------------
check_forceDeleteBranch()
{
    local lBranch=${1}
    getAnswer "About to delete branch ${lBranch} from all projects. Continue?" || return 1

    if [[ -n $(listBranches | grep -v Project | grep " ${lBranch}") ]]; then
	printf "Branch ${lBranch} is active in the following projects. Will not delete."
	printProjectsForBranch
	return 1
    fi

    return 0
}


#----------------------------------------------
forceDeleteBranch()
{
    git branch -D ${1}
}

#----------------------------------------------
check_deleteBranch()
{
    check_forceDeleteBranch $@
}

#----------------------------------------------
deleteBranch()
{
    git branch -d ${1}
}

#----------------------------------------------
check_fetchFromRemote()
{
    return 0
}

#----------------------------------------------
fetchFromRemote()
{
    git fetch
}

#----------------------------------------------
check_switchBranch()
{
    checkLocalChanges switch || return 1
}

#----------------------------------------------
switchBranch()
{
    git checkout ${1} >/dev/null
}

#----------------------------------------------
check_trackBranch()
{
    local lBranch=${1}

    if [[ ${lBranch} == 'master' ]]; then
	printf "Branch %s is already tracked.\n" ${lBranch}
	return 1
    fi

    ## Check that all projects are on the same lBranch
    if [[ $(printCurrentBranch | wc -w) -gt 1 ]]; then
	printf "Mixed branches found. Switch first to %s\n" ${lBranch}
	return 1
    elif [[ -z $(printCurrentBranch | grep ${lBranch}) ]]; then
	printf "Branch '%s' is not active.\n" ${lBranch}
	return 1
    fi

    ## Check for local changes
    checkLocalChanges track || return 1

    return 0
}

#----------------------------------------------
trackBranch()
{
    local lBranch=${1}

    git fetch

    git push origin ${lBranch} >/dev/null &&
    git config branch.${lBranch}.remote origin >/dev/null && 
    git config branch.${lBranch}.merge refs/heads/${lBranch} >/dev/null
}

#----------------------------------------------
check_mergeBranch()
{
    local lFromBranch=${1}
    local lToBranch=${2}

    checkLocalChanges merge || return 1
    local lActiveBranches=$(printActiveBranches)

    # Check that there are no mixed branches
    if [[ $(echo ${lActiveBranches} | wc -w) != 1 ]]; then
	printf "Mixed active branches found. Will not continue.\n"
	echo ${lActiveBranches}
	return 1
    fi

    # Check that from- and to- branches are not the same
    if [[ ${lToBranch} == ${lFromBranch} ]]; then
	printf "From and to branches are the same: %s and %s\n" ${lFromBranch} ${lToBranch}
	return 1
    fi

    # Check that the current active branch is the same as the from-branch
    if [[ ${lActiveBranches} != ${lToBranch} ]]; then
	printf "The active branch is not ${lToBranch}, but %s\n" "${lActiveBranches}"
	printf "Make ${lToBranch} active before merging\n"
	return 1
    fi


}

#----------------------------------------------
mergeBranch()
{
    #git checkout ${1} > /dev/null
    #branch -s ${2}
    git merge ${1}
}


#----------------------------------------------
# Main script
#----------------------------------------------
ARGS=$(getopt -o hx:c:d:D:fs:t:m:l -l "help,exclude:,create:,delete:,DELETE:,fetch,switch:,track:,merge:,list::" -n "$(basename ${0})" -- "$@")

# If wrong arguments, print usage and exit
if [[ $? -ne 0 ]]; then
    printUsage
    exit 1;
fi

eval set -- "$ARGS"

# Go th the code directory - don't do it! Bad when you have multiple copies of the code.
#if [[ $(pwd) != "${HOME}/code" ]]; then
#    cd ~/code
#fi

## Parse options
toExclude=""
while true; do
    case ${1} in
	-h|--help)
	    printUsage
	    exit 0
	    ;;
	-x|--exclude)
	    toExclude="${toExclude},""${2},"
	    shift 2
	    ;;
	-c|--create)
	    task='createBranch'
	    arguments=${2}
	    shift 2
	    ;;
	-d|--delete)
	    task='deleteBranch'
	    arguments=${2}
	    shift 2
	    ;;
	-D|--DELETE)
	    task='forceDeleteBranch'
	    arguments=${2}
	    shift 2
	    ;;
	-f|--fetch)
	    task='fetchFromRemote'
	    shift
	    ;;
	-s|--switch)
	    task='switchBranch'
	    arguments=${2}
	    shift 2
	    ;;
	-t|--track)
	    task='trackBranch'
	    arguments=${2}
	    shift 2
	    ;;
	-m|--merge)
	    task='mergeBranch'
	    arguments=${2}
	    shift 2
	    ;;
	-l|--list)
	    shift
	    listBranches ${2}
	    exit 0
	    ;;
	--)
	    shift
	    break
	    ;;
	"")
	    # This is necessary for processing missing optional arguments 
	    shift
	    ;;
    esac
done

# If no task specified, default to list
if [[ -z ${task} ]]; then
    listBranches
    exit 0
fi

gitDirs=$(listRepos)
alignSize=$(getAlignSize ${gitDirs})


# If no from-branch given, take the current active one
if [[ ${task} = 'mergeBranch' ]]; then
    if [[ $# -lt 1 ]]; then
	toBranch=$(printActiveBranches)
	if [[ $(echo ${toBranch} | wc -w) -gt 1 ]]; then
	    printf "Mixed active branches found"
	    exit 0
	fi
	arguments=${arguments}" "${toBranch}
    fi
fi

## Run checks for the given task
check_${task} ${arguments} $* || exit 1

# Then run the task
for d in ${gitDirs}; do
    if [[ -n $(echo ${toExclude} | grep ",${d},") ]]; then
	echo "Skipping project ${d}"
	continue
    fi
    cd ${d}
    n=$(( alignSize - ${#d} ))
    output=$(${task} ${arguments} $* 2>&1)
    printf "%s%${n}s: %s\n" "$(pwd)" "" "${output}"
    cd ->/dev/null
done
