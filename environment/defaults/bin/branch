#!/bin/bash

source ~/.userfunctions

#----------------------------------------------
printUsage()
{
cat << %%USAGE%%
     Usage: $(basename ${0}) [-h]
            $(basename ${0}) [-xprj1[,prj2,...]] <-c|--create>  branchName
            $(basename ${0}) [-xprj1[,prj2,...]] <-d|--delete>  branchName
            $(basename ${0}) [-xprj1[,prj2,...]] <-s|--switch>  branchName
            $(basename ${0}) [-xprj1[,prj2,...]] <-m|--merge>   toBranch fromBranch
            $(basename ${0}) [-xprj1[,prj2,...]] <-l|--list> [all]

    Description:
       Creates/deletes a branch for all checked-out products.

    Options:
       -h
       --help
             Print this help message and exit.

       -xprj1,prj2,...
       --exclude prj1,prj2,...
             The listed projects will be excluded.

       -c branchName
       --create branchName
             Create branches branchName (one for each project). 

       -d branchName
       --delete branchName
             Delete branches branchName (one for each project).

       -s branchName
       --switch branchName
             Switch to branchName for all projects.

       -m fromBranch [toBranch]
       --merge fromBranch [toBranch]
             Merge the changes in fromBranch to toBranch

       -l [all]
       --list [all]
             List the current branch for each project. If option 'all' is
	     provided, lists all the branches for each project.

       <x|y>:
             One of the arguments in the brackets must be provided

%%USAGE%%
}

#----------------------------------------------
printProjectsForBranch()
{
    local lAll=${1}
    listBranches ${lAll} | sed -n "/Project/,/${lBranch}/p" | grep Project | replace Project ""
}


#----------------------------------------------
printActiveBranches()
{
    listBranches | grep Project | awk '{print $NF}' | sort | uniq
}

#----------------------------------------------
checkLocalChanges()
{
    local lActivity=${1}
    local lBranchesWithChanges=$(stall -s)
    if [[ -n ${lBranchesWithChanges} ]]; then
	printf "\nThe following branches have local changes\n"
	echo "${lBranchesWithChanges}"
	printf "\nCommit/stash changes before ${lActivity}ing.\n"
	return 1
    fi
    return 0

}

#----------------------------------------------
listBranches()
{
    local lAll="${1}"

    local lGitDirs=$(listRepos)
    local lAlignSize=$(getAlignSize ${lGitDirs})

    if [[ ${lAll} = 'all' ]]; then
	printf "All branches: \n"
    else
	printf "\nCurrent active branches \n-----------------------\n"
    fi

    for p in ${lGitDirs}; do
	cd ${p}
	if [[ ${lAll} = 'all' ]]; then
	    printf "Project %s: \n%s\n\n" "${p}" "$(git branch --list)"
	else
	    n=$(( lAlignSize - ${#p} ))
	    printf "Project %s%${n}s: %s\n" "${p}"  "" "$(git branch --list | grep '^*' | awk '{print $NF}')"
	fi
	cd ->/dev/null
    done
}

#----------------------------------------------
check_createBranch()
{
    local lBranch=${1}

    if [[ -n $(listBranches all | grep -v Project | grep " ${lBranch}") ]]; then
	printf "Branch '${lBranch}' already exists in the following projects.\n"
	printProjectsForBranch all
	return 1
    fi

    return 0
}

#----------------------------------------------
createBranch()
{
    local lBranch=${1}

    git branch ${lBranch}
    git checkout ${lBranch}
}

#----------------------------------------------
check_forceDeleteBranch()
{
    local lBranch=${1}
    if [[ -n $(listBranches | grep -v Project | grep " ${lBranch}") ]]; then
	printf "Branch ${lBranch} is active in the following projects. Will not delete."
	printProjectsForBranch
	return 1
    fi

    return 0
}


#----------------------------------------------
forceDeleteBranch()
{
    git branch -D ${1}
}

#----------------------------------------------
check_deleteBranch()
{
    check_forceDeleteBranch $@
}

#----------------------------------------------
deleteBranch()
{
    git branch -d ${1}
}

#----------------------------------------------
check_switchBranch()
{
    checkLocalChanges switch || return 1
}

#----------------------------------------------
switchBranch()
{
    git checkout ${1}
}

#----------------------------------------------
check_mergeBranch()
{
    local lToBranch=${1}
    local lFromBranch=${2}

    checkLocalChanges merge || return 1
    local lActiveBranches=$(printActiveBranches)

    # Check that there are no mixed branches
    if [[ $(echo ${lActiveBranches} | wc -w) != 1 ]]; then
	printf "Mixed active branches found. Will not continue.\n"
	echo ${lActiveBranches}
	return 1
    fi

    # Check that from- and to- branches are not the same
    if [[ ${lToBranch} == ${lFromBranch} ]]; then
	printf "From and to branches are the same: %s and %s\n" ${lFromBranch} ${lToBranch}
	return 1
    fi

    # Check that the current active branch is the same as the from-branch
    if [[ ${lActiveBranches} != ${lFromBranch} ]]; then
	printf "The active branch is not ${lFromBranch}, but %s\n" "${lActiveBranches}"
	printf "Make ${lFromBranch} active before merging"
	return 1
    fi


}

#----------------------------------------------
mergeBranch()
{
    git checkout ${1} > /dev/null
    git merge ${2}
}


#----------------------------------------------
# Main script
#----------------------------------------------
ARGS=$(getopt -o hx:c:d:D:s:m:l -l "help,exclude:,create:,delete:,DELETE:,switch:merge:,list::" -n "$(basename ${0})" -- "$@")

# If wrong arguments, print usage and exit
if [[ $? -ne 0 ]]; then
    printUsage
    exit 1;
fi

eval set -- "$ARGS"

# Go th the code directory
if [[ $(pwd) != "${HOME}/code" ]]; then
    cd ~/code
fi

## Parse options
toExclude=""
while true; do
    case ${1} in
	-h|--help)
	    printUsage
	    exit 0
	    ;;
	-x|--exclude)
	    toExclude="${toExclude},""${2},"
	    shift 2
	    ;;
	-c|--create)
	    task='createBranch'
	    arguments=${2}
	    shift 2
	    ;;
	-d|--delete)
	    task='deleteBranch'
	    arguments=${2}
	    shift 2
	    ;;
	-D|--DELETE)
	    task='forceDeleteBranch'
	    arguments=${2}
	    shift 2
	    ;;
	-s|--switch)
	    task='switchBranch'
	    arguments=${2}
	    shift 2
	    ;;
	-m|--merge)
	    task='mergeBranch'
	    arguments=${2}
	    shift 2
	    ;;
	-l|--list)
	    shift
	    listBranches ${2}
	    exit 0
	    ;;
	--)
	    shift
	    break
	    ;;
	"")
	    # This is necessary for processing missing optional arguments 
	    shift
	    ;;
    esac
done

# If no task specified, default to list
if [[ -z ${task} ]]; then
    listBranches
    exit 0
fi

gitDirs=$(listRepos)
alignSize=$(getAlignSize ${gitDirs})


# If no from-branch given, take the current active one
if [[ ${task} = 'mergeBranch' ]]; then
    if [[ $# -lt 1 ]]; then
	toBranch=$(printActiveBranches)
	if [[ $(echo ${toBranch} | wc -w) -gt 1 ]]; then
	    printf "Mixed active branches found"
	    exit 0
	fi
	arguments=${arguments}" "${toBranch}
    fi
fi

## Run checks for the given task
check_${task} ${arguments} $* || exit 1

# Then run the task
for d in ${gitDirs}; do
    if [[ -n $(echo ${toExclude} | grep ",${d},") ]]; then
	echo "Skipping project ${d}"
	continue
    fi
    cd ${d}
    n=$(( alignSize - ${#d} ))
    output=$(${task} ${arguments} $* 2>&1)
    printf "%s%${n}s: %s\n" "$(pwd)" "" "${output}"
    cd ->/dev/null
done
