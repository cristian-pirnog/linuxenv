#!/bin/bash

# Run this scrip to install a working environment on CentOS 6.5

#----------------------------------------------
printUsage()
{
cat << %%USAGE%%
Usage: $(basename ${0}) [-h]
       $(basename ${0}) user@host [accounts|software|ssh|full]

    Description:
        Install the production environment on the given host, for the given user.

    Options:
       -h
       --help
             Print this help message and exit.

    Tasks:
       accounts
            Create the trading and test accounts.

       software
            Install the software needed for running the live binary.

       ssh
	    Distribute the ssh keys of the current user to the trading accounts.

       full
	    Do all tasks from above.

%%USAGE%%
}


#----------------------------------------------
hasTask()
{
    local lTaskName=$2
    echo ${1} | grep "${lTaskName}"'\( \|$\)'
}

#----------------------------------------------
createGroup()
{
    local lGroup=${1}
    if [[ -z $(getent group ${lGroup} ) ]]; then
	echo "\tCreating group ${lGroup}"
	groupadd -f ${lGroup}
    fi
}

#----------------------------------------------
setupAccount()
{
    local lAccountName=${1}

    createGroup prod
    createGroup data

    if [[ -n $(getent passwd ${lAccountName}) ]]; then
	echo "User ${lAccountName} already exists. Will not create"
    else
	echo "Creating user: ${lAccountName}"
	useradd -g prod -G data ${lAccountName}
    fi

    local lHomeDir="/home/${lAccountName}"

    # Creat the .ssh dir
    local lSshDir="${lHomeDir}/.ssh"
    mkdir -p ${lSshDir}
    chmod 700 ${lSshDir}
    touch ${lSshDir}/authorized_keys
    chmod 600 ${lSshDir}/authorized_keys

    # Create the live dir
    mkdir -p ${lHomeDir}/live/bin
    mkdir -p ${lHomeDir}/live/log
    mkdir -p ${lHomeDir}/live/dat

    # Clone/update the git repo
    targetGitDir=${lHomeDir}/.${lAccountName}_config
    if [[ ! -d ${targetGitDir} ]]; then
	git clone crpi@10.199.10.104:/volume1/repository/environment ${targetGitDir} || return 1
    fi
    cd ${targetGitDir} && sudo -u ${lAccountName} ./update_user --nopull

    # Make user owner of all the files in his home directory
    chown ${lAccountName}:prod -R ${lHomeDir}

    # TODO: Deploy the authorized keys for the production user


}

#----------------------------------------------
prepare_accounts()
{
    # Do nothing
    return 0
}

#----------------------------------------------
run_accounts()
{
    for ac in ${productionAccounts}; do
	setupAccount ${ac} || return 1
    done

    return 0
}

#----------------------------------------------
prepare_software()
{
    echo "Updating the software files on the target machine"
    ssh -A ${userAtHost} "mkdir -p ${tmpDir}" || exit 1
    ${rsyncNoTimeUpdate} '/mnt/config/RONIN/production_env/' ${userAtHost}:${tmpDir} || exit 1
    return 0
}

#----------------------------------------------
run_software()
{
    cd /home/${user}/${tmpDir}
    yum install bzip2-devel
    ./do_gcc_make_install.sh
    ./env_for_building_using_4.8.2.sh
    ./do_cmake_make_install.sh
    ./do_boost_make_install.sh
    ./do_python_make_install.sh
}

#----------------------------------------------
prepare_ssh()
{
    local lPublicKeyFile=~/.ssh/id_rsa.pub

    # Ask for the public key file
    printf "Enter public key file (default %s): " ${lPublicKeyFile}
    read answer

    if [[ -n ${answer} ]]; then
	lPublicKeyFile=${answer}
    fi

    # Check that the public key file exists
    if [[ ! -f ${lPublicKeyFile} ]]; then
	printf "Public key file does not exist: ${lPublicKeyFile}"
	return 1
    fi

    scp -q ${lPublicKeyFile} ${userAtHost}:${tmpDir}/publicKey || return 1
}

#----------------------------------------------
run_ssh()
{
    local lPublicKeyFile="/home/${user}/${tmpDir}/publicKey"
    if [[ ! -f ${lPublicKeyFile} ]]; then
	echo "File not found: ${lPublicKeyFile}"
	return 1
    fi

    local lKey=$(cat ${lPublicKeyFile})
    for ac in ${productionAccounts}; do
	local lTargetFile="/home/${ac}/.ssh/authorized_keys"
	if [[ -z $(grep "${lKey}" ${lTargetFile}) ]]; then
	    cat ${lPublicKeyFile} > ${lTargetFile}
	else
	    echo "The key is already in file ${lTargetFile}"
	fi
    done

    rm ${lPublicKeyFile}
}


#----------------------------------------------
# Main script
#----------------------------------------------
ARGS=$(getopt -o h -l "help,local" -n "$(basename ${0})" -- "$@")

# If wrong arguments, print usage and exit
if [[ $? -ne 0 ]]; then
    printUsage
    exit 1;
fi

eval set -- "$ARGS"

prefix=prepare
localRun=0
while true; do
    case ${1} in
    -h|--help)
        printUsage
        exit 0
        ;;
    --local)
        prefix=run
	localRun=1
        shift
        ;;
    --)
        shift
        break
        ;;
    "")
        # this is necessary for processing missing optional arguments 
        shift
        ;;
    esac
done

if [[ ${localRun} != 1 ]] && [[ $# -lt 2 ]]; then
    printUsage
    exit 1
fi

# Parse input arguments
userAtHost=${1}
user=$(echo ${userAtHost} | awk -F '@' '{print $1}')
shift
tasks=$@

# Constants
knownTasks="accounts software ssh"
productionAccounts="arbytetest arbyteprod"
syncCommand="rsync -azvh"
rsyncNoTimeUpdate="rsync -rlpdogzvhc --progress"
tmpDir='tmp/production_env'

if [[ -n $(hasTask "${tasks}" full) ]]; then
    tasks=${knownTasks}
fi

# Check if all tasks are supported
for t in ${tasks}; do
    if [[ -z $(hasTask "${knownTasks}" ${t}) ]]; then
	printf "\nUnsupported task '%s'.\n\n" ${t}
	printUsage
	exit 1
    fi
done

## Upload itself to the target server, when not local run
if [[ ${localRun} == 0 ]]; then
    echo -e "\nExecuting the install script on the local machine (preparing target machine)"
    ssh -A ${userAtHost} "mkdir -p bin" || exit 1
    scp -q ${0} ${userAtHost}:${tmpDir} || exit 1
fi

# Executes the tasks...
for t in ${tasks}; do
    echo -e "  Doing task ${prefix}_${t}"
    ${prefix}_${t} || exit 1
done

# ... and then executes itself on the target machine
if [[ ${localRun} == 0 ]]; then
    echo -e "\nExecuting the install script on the target machine"
    ssh -A -t ${userAtHost} "cd ${tmpDir} && sudo ~/${tmpDir}/$(basename $0) --local ${userAtHost} ${tasks} " || exit 0
fi
