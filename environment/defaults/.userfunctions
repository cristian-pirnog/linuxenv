# -*- mode: sh -*- #

shopt -s expand_aliases
. ~/.aliases

#----------------------------------------------
# General functions
#----------------------------------------------
getAnswer()
{
    # Pop the question
    local question="${1}"
    if [[ -z ${question} ]]; then
	question="Would you like to continue?"
    fi
    question=${question}" [y\n]"
    printf "\n%s " "${question}"

    # Get the answer
    local answer
    read answer
    case $answer in
        y|Y|yes|Yes|YES)
	    return 0
	    ;;
    esac
    return 1
}

#----------------------------------------------
getAlignSize()
{
    local list="$*"
    local alignSize=0
    for d in ${list}; do
	if [[ ${alignSize} -lt ${#d} ]]; then
	    alignSize=${#d}
	fi
    done
    echo ${alignSize}
}



#----------------------------------------------
vif()
{
    vi $(f $*)
}


#----------------------------------------------
lower()
{
    echo $* | tr [:upper:] [:lower:]
}

#----------------------------------------------
allSourceFiles()
{
    local myHeaders=".h .hpp"
    local mySources=".C .cpp"
    
    local option=$1    
    
    case ${option} in
        "?")
            echo "Usage: `basename allSourceFiles` [?|-h|-s|pattern]"
            return 0
            ;;
        "-h")
            myExtensions="${myHeaders}"
            ;;
        "-s")
            myExtensions="${mySources}"
            ;;
	
	'')
	    myExtensions="${myHeaders} ${mySources}"
	    ;;
        
        *)
            myExtensions=${@}
            ;;
    esac 
    
    for e in ${myExtensions}; do
	find . -name '*'$e
    done
}

#----------------------------------------------
listRepos()
{
    for f in $(find . -maxdepth 5 -type d -name .git | sort); do
	dirname $f | replace './' ''
    done
}

#----------------------------------------------
isGitRepo()
{
    myDir=$(pwd)
    while [[ ${myDir} != "/" ]]; do
	if [[ -d ${myDir}/.git ]]; then
	    echo 1
	    return
	fi
	myDir=$(dirname ${myDir})
    done
    echo 0
}

#----------------------------------------------
cleanall()
{
    # 
    if [[ $# -gt 0 ]]; then
	types="$@"
    else
	types="Debug Release"
    fi

    for type in ${types}; do
	# Only Debug/Release allowed
	if [[ ${type} != 'Debug' ]] && [[ ${t} != 'Debug' ]]; then
	    echo "Unsupported type ${type}. Will not clean"
	    continue
	fi

	echo "Cleaning ${type} builds"
	for repo in $(listRepos); do
	    echo rm ${repo}/${type}
	done
    done
}



#----------------------------------------------
st()
{
    if [[ $(isGitRepo) -eq 1 ]]; then
	git status $@
    else
	stall $@
    fi
}



#----------------------------------------------
dif()
{
    if [ ! -d .user ]; then
        getAnswer "Directory \"`pwd`/.user\" doesn't exist. Would you like to create it?" && mkdir .user
    fi

    if [[ -d svn ]]; then
	svndif $@
    elif [[ $(isGitRepo) -eq 1 ]]; then
	gitdif $@
    else
	echo "Unknown repository type (supported: git, SVN)"
    fi
}


#----------------------------------------------
# Function for pushing changes to all repos.
pizda()
{
    # Changed directories will have a space and some text
    local command=""
    gitDirs=$(stall -p | grep ' ' | cut -d ' ' -f 1)
    local alignSize=$(getAlignSize ${gitDirs})

    if [[ -z ${gitDirs} ]]; then
	printf "No changes found to push. Exiting.\n"
	return 0
    fi

    echo -e "About to push changes to the following repos:\n"
    stall -p | grep ' ' | awk '{first=$1; $1=""; print first":"$0" "}' | column -t -s ":"
    ! getAnswer && return 0

    for d in ${gitDirs}; do
	n=$(( alignSize - ${#d} ))
	printf "Pushing for %s%${n}s   : " "${d}" ""
	cd "${d}"
	logFile=.git.push.log
	git push > ${logFile} 2>&1
	if [[ $? -ne 0 ]]; then
	    printf "There were problems. See log file ${logFile}\n"
	else
            printf "Done\n"
	fi
	cd ->/dev/null
    done
}



#----------------------------------------------
# Function stall
#
# Options:
#
#   -s Outputs only branches that have local changes.
#
#   -p Output formatted for use with pizda.
#
stall()
{
    local gitDirs=$(listRepos)
    local alignSize=$(getAlignSize ${gitDirs})

    if [[ ${1} == '-s' ]]; then
	local forNext=1
    elif [[ ${1} == '-p' ]]; then
	local forPizda=1
#    else
#clear # This puts non-printing characters in the output	(which messes-up the function pizda)
    fi

    local lOldPdw=${OLDPWD}
    for d in ${gitDirs}; do
	currMsg=""
	cd ${d}
	local status=$(git status)
	local lBranchName=$(git branch --list | grep '^*' | awk '{print $NF}')

	# Check for untracked files
	local hasChanges=0
	local hasChangesToPush=0
	if [[ -n $(echo $status | grep "Untracked files") ]]; then
	    currMsg=${currMsg}" has untracked files"
	    hasChanges=$(($hasChanges || 1))
	fi

	if [[ -n $(echo $status | grep "Changes not staged") ]]; then
	    if [[ -n ${currMsg} ]]; then currMsg=${currMsg}" AND"; fi
	    currMsg=${currMsg}" has changes"
	    hasChanges=$(($hasChanges || 1))
	fi

	if [[ -n $(echo $status | grep "Changes to be committed") ]]; then
	    if [[ -n ${currMsg} ]]; then currMsg=${currMsg}" AND"; fi
	    currMsg=${currMsg}" has changes staged for commiting"
	    hasChanges=$(($hasChanges || 1))
	fi
	
	if [[ -n $(echo $status | grep "Your branch is ahead") ]]; then
	    if [[ -n ${currMsg} ]]; then currMsg=${currMsg}" AND"; fi
	    currMsg=${currMsg}" is ahead of origin"
	    hasChangesToPush=$(($hasChangesToPush || 1))
	fi

	if [[ -n $(echo $status | grep "have diverged,") ]]; then
	    if [[ -n ${currMsg} ]]; then currMsg=${currMsg}" AND"; fi
	    currMsg=${currMsg}" has diverged from origin"
	    hasChangesToPush=$(($hasChangesToPush || 1))
	fi

	if [[ ${forNext} ]] && [[ ${hasChanges} == "1" ]]; then
	    printf "%s:%s\n" ${d} "${currMsg}"
	elif [[ ${forPizda} ]] && [[ ${hasChangesToPush} == "1" ]]; then
	    printf "%s:%s\n" ${d} "${currMsg}."
	elif [[ ! ${forNext} ]] && [[ ! ${forPizda} ]]; then
	    n=$(( alignSize - ${#d} ))
	    printf "%s%${n}s (%s) %s\n" ${d} "" "${lBranchName}" "${currMsg}"
	fi
	cd ->/dev/null
    done
    OLDPWD=${lOldPdw}
}


#----------------------------------------------
# Options: -c --> go to the next branch that has changes
#
next()
{
    local nextInfo=$(stall -s | head -n 1 | tail -n 1)
    local nextDir=$(echo ${nextInfo} | cut -d ":"  -f 1)

    if [ -n "${nextDir}" ]; then
	cd ${nextDir}
	echo -e "Repo: ${nextDir}\n"
	st
    else
	echo "No changes found"
    fi
}

#----------------------------------------------
ric()
{
    if [[ $# -lt 2 ]]; then
	echo "Usage: ric from to [filePattern]"
	return 1
    fi
    
    from=$1
    to=$2
    shift 2
    
    myFiles=`allSourceFiles $*`

    IFS=$'\n'
    replace "$from" "$to" -- ${myFiles}
    unset IFS
}

#------------------------------------------
deSCize()
{
    for tag in $*; do
	tagCopy=${tag}
	prefix=''
	if [[ ${tagCopy:0:1} == '_' ]]; then
            prefix='_'
            tagCopy=${tagCopy:1}
	fi
	
	firstLetter=${tagCopy:1:1}
	mainBody=${tagCopy:2}
	
	# For members
	firstLetter=$(lower ${firstLetter})
	
	ric "${tag}" "${prefix}${firstLetter}${mainBody}"
    done
}

#------------------------------------------
deGet()
{
    for tag in $*; do
	
	# Check that it starts with get
	if [[ ${tag:0:3} != 'get' ]]; then
	    echo "tag $tag does not start with 'get'"
	    continue
	fi
	
	tagBody=${tag:4}
	firstLetter=$(lower ${tag:3:1})
	ric "${tag}()" "${firstLetter}${tagBody}()"
    done
}


#----------------------------------------------
lna()
{
    st | grep ? | awk '{print $NF}'
}


# The environment overrides
if [ -f $HOME/.userenv_overrides ]; then
    . $HOME/.userenv_overrides
fi

#----------------------------------------------
# TrueCrypt functions
#----------------------------------------------
mapLoopDevice()
{
    local fileName="${1}"

    # Check that the file is not already mapped
    local deviceName=$(losetup -j "${fileName}" | cut -d ' ' -f 1)
    if [[ -n ${deviceName} ]]; then
	echo "File ${fileName} already mapped as " $(mount | grep ${deviceName} | cut -d ' ' -f 3)
	return 1
    fi
    
    deviceName=$(sudo losetup -f --show "${fileName}")
    echo ${deviceName}
}

#----------------------------------------------
getNextMapping()
{
    local mappingName=""
    # Get the next available trucryptX name in /dev/mapper
    for i in $(seq -w 1 10); do
	mappingName="truecrypt${i}"
	if [[ -n $(ls /dev/mapper | grep ${mappingName}) ]]; then
	    if [[ ${i} == 10 ]]; then
		# All 10 device mapping points are used. Will exit without mapping
		return 1
	    fi
	else
	    break
	fi
    done
    
    echo ${mappingName}
}

#----------------------------------------------
tc()
{
    if [[ $# -lt 1 ]]; then
	echo "Usage: tc [usb|deviceName] mountPoint"
	return 1
    fi

    deviceName=${1}
    mountPoint=${2}

    if [[ $(lower ${deviceName}) == "usb" ]]; then
	echo "Fetching the last usb device mounted"
	deviceName="/dev/"$(dmesg  | grep ': sd' | tail -1 | awk '{print $NF}')
    fi

    ! getAnswer "About to mount device '${deviceName}'. Continue? " && return 1

    # If the device is actually a file on the disk, map it to a loop device
    if [[ -z $(echo ${deviceName} | grep '/dev/sd') ]]; then
	# ! getAnswer "Looks like you're trying to mount a TC file. Continue?" && return 1

	fileName="${deviceName}"	
	deviceName=$(mapLoopDevice "${fileName}")
	echo deviceName=${deviceName}
	if [[ $? -eq 1 ]]; then
	    echo ${deviceName}
	    return 1
	fi
    fi

    # TODO: Check if the device was already mapped
    mappingName=$(getNextMapping)
    if [[ -z ${mappingName} ]]; then
	echo "Could not get device mapping. Exiting."
	return 1
    fi

    # Get the next available mapping point
    if [[ -z ${mountPoint} ]]; then
	baseMountDir="$HOME/truecrypt"
	for i in $(seq -w 1 10); do
	    mountPoint=${baseMountDir}/tc${i}
	    if [[ -n $(mount | grep ${mountPoint}) ]]; then
		echo "Mount point ${mountPoint} is already used"
		if [[ ${i} == 10 ]]; then
		    echo "All 10 mount points are used. Will exit without mapping."
		    return 1
		fi
	    else
		break
	    fi
	done
    fi

    mkdir -p ${mountPoint}
    sudo /sbin/cryptsetup -y -c aes -s 256 -h sha256 create ${mappingName} ${deviceName}
    sudo mount /dev/mapper/${mappingName} ${mountPoint}

    echo "TC Device ${deviceName} mapped as ${mountPoint}"
}

#----------------------------------------------
untc()
{
    if [[ $# -lt 1 ]]; then
	echo "Usage: untc mountPoint"
	return 1
    fi

    mountPoint=$(realpath ${1})

    devName=$(mount | grep " ${mountPoint} " | cut -d ' ' -f 1)
    if [[ -z ${devName} ]]; then
	echo "Mount point ${mountPoint} is not in the mount table. Aborting"
	return 1
    fi
    loopDevice=$(sudo cryptsetup status ${devName} | grep device | awk '{print $NF}')

    if [[ -z ${loopDevice} ]]; then
	echo "Could not find the loop device"
	echo mountPoint=${mountPoint}
	echo devName=${devName}
	echo loopDevice=${loopDevice}

	return 1
    fi

    sudo umount ${mountPoint}
    sudo /sbin/cryptsetup close ${devName}
    sudo losetup -d ${loopDevice}

    if [[ -n $(ls ${mountPoint}) ]]; then
	echo "Mount point ${mountPoint} not empty. Will not remove"
	return 1
    else
	rm -rf ${mountPoint}
    fi
}


#----------------------------------------------
tcnew()
{
    if [[ $# -lt 2 ]]; then
	echo "Usage: tcnew fileName fileSize"
	return 1
    fi

    fileName="${1}"
    fileSize=${2}

    # Check if the file exists
    if [[ -f ${fileName} ]]; then
	echo "File exists: ${fileName}"
	return 1
    fi

    # Create the file
    dd if=/dev/zero of="${fileName}" bs=1 count=0 seek=${fileSize}
    # Map it to a loop device
    deviceName=$(mapLoopDevice "${fileName}")
    if [[ $? -eq 1 ]]; then
	echo ${deviceName}
	return 1
    fi
    
    # Create the volume
    echo "About to create the TrueCrypt volume"
    sudo tcplay -c -d ${deviceName} -a whirlpool -b AES-256-XTS
    
    if [[ $? -ne 0 ]]; then
	echo "Could not create the TrueCrypt volume. Exiting"

	# Delete the mapping
	sudo losetup -d ${deviceName}

	return 1
    fi

    echo deviceName=${deviceName}
    return 1

    # Delete the mapping
    sudo losetup -d ${deviceName}

    # 
    sudo tcplay --map=${mappingName} --device=${deviceName}
    mkfs.ext4 /dev/mapper

    # Mount the volume
    tc ${fileName}
}


mountMarketData()
{
    targetDir="/mnt/MD"
    if [[ -n $(mount | grep " ${targetDir} ") ]]; then
	echo $(mount | grep " ${targetDir} " | awk '{print $1 " is already mounted on " $3". Exiting."}')
	return 0
    fi	
    tc /mnt/MD_crypt/disk.crypt ${targetDir}
}


unmountMarketData()
{
    untc /mnt/MD/
}
