# -*- mode: sh -*- #

shopt -s expand_aliases
. ~/.aliases

#----------------------------------------------
# General functions
#----------------------------------------------
getAnswer()
{
    # Pop the question
    local question="${1}"
    if [[ -z ${question} ]]; then
	question="\nWould you like to continue?"
    fi
    question=${question}" [y\n]"
    printf "%s " ${question}

    # Get the answer
    local answer
    read answer
    case $answer in
        y|Y|yes|Yes|YES)
	    return 0
	    ;;
    esac
    return 1
}

#----------------------------------------------
getAlignSize()
{
    local list="$*"
    local alignSize=0
    for d in ${list}; do
	if [[ ${alignSize} -lt ${#d} ]]; then
	    alignSize=${#d}
	fi
    done
    echo ${alignSize}
}



#----------------------------------------------
vif()
{
    vi $(f $*)
}


#----------------------------------------------
lower()
{
    echo $* | tr [:upper:] [:lower:]
}

#----------------------------------------------
allSourceFiles()
{
    local myHeaders=".h .hpp"
    local mySources=".C .cpp"
    
    local option=$1    
    
    case ${option} in
        "?")
            echo "Usage: `basename allSourceFiles` [?|-h|-s|pattern]"
            return 0
            ;;
        "-h")
            myExtensions="${myHeaders}"
            ;;
        "-s")
            myExtensions="${mySources}"
            ;;
	
	'')
	    myExtensions="${myHeaders} ${mySources}"
	    ;;
        
        *)
            myExtensions=${@}
            ;;
    esac 
    
    for e in ${myExtensions}; do
	find . -name '*'$e
    done
}

#----------------------------------------------
listRepos()
{
    find . -maxdepth 5 -type d -name .git | sort | xargs dirname | replace './' ''
}

#----------------------------------------------
isGitRepo()
{
    myDir=$(pwd)
    while [[ ${myDir} != "/" ]]; do
	if [[ -d ${myDir}/.git ]]; then
	    echo 1
	    return
	fi
	myDir=$(dirname ${myDir})
    done
    echo 0
}

#----------------------------------------------
cleanall()
{
    if [[ $# -gt 0 ]]; then
	types="$@"
    else
	types="Debug Release"
    fi

    for type in ${types}; do
	echo "Cleaning ${type} builds"
	for d in $(f ${type}); do 
	    echo -e "\t$d"
	    cd $d
	    make clean >> /dev/null
	    cd ->/dev/null
	done
    done
}



#----------------------------------------------
st()
{
    if [[ $(isGitRepo) -eq 1 ]]; then
	git status $@
    else
	stall $@
    fi
}


#----------------------------------------------
gitdif()
{
    if [ ! -d .user ]; then
        getAnswer "Directory \"`pwd`/.user\" doesn't exist. Would you like to create it?" && mkdir .user
    fi

    if [[ -z ${DISPLAY} ]]; then
        emacs_OPTIONS="-nw"
    else
        emacs_OPTIONS="-geometry 186x50"
    fi

    # Check for conflict
    CONFLICTS=`st --porcelain | grep '^C'`
    if [ ${#CONFLICTS} -ne 0 ]
    then
	echo -e "\nConflicts detected. First resolve them before proceeding."
	return 0 
    fi

    diffOptions="--cached"
    if [[ -n $(st | grep 'not staged') ]]; then
	diffOptions=""
	echo -e "\nThere are changes not staged for commit\n"
	st | grep -A 10 'not staged'
#	! getAnswer && return 1
    fi

    # If the directory .user exist ==> write the result to .user/git.diff
    if [ -d .user ]; then
	git diff ${diffOptions} $@ > .user/git.diff

        # Back-up the 'git.log' file (if it exist)...
        if [ -f .user/git.log ]
        then
            cp .user/git.log .user/git.log.org
        fi

        CHANGED_FILES=`st --porcelain | grep -v '^?' | grep -v '^U' | grep -v '^P'`

        echo "$CHANGED_FILES"

        # ... then write the skeleton in the new one
        echo -e "Summary: \nDetails:" > .user/git.log

        IFS=$'\n'
        index=1
        for FILE_STRING in $CHANGED_FILES
          do

          # Split the string into TYPE & FILE
          TYPE=`echo "$FILE_STRING" | awk '{print $1}'`
          FILE=`echo "$FILE_STRING" | awk '{print $NF}'`

          # Check whether it should put the whole path (defaults to YES)
          if [[ -f ".user/.shortpath" ]]; then 
              FILE_NAME=`basename "$FILE"`
          else
              FILE_NAME=$FILE
          fi

          POINT="."
          if [[ "$TYPE" = "A" ]]
          then
              PREFIX_TEXT="Added file "
              FILE_NAME=$FILE
          elif [[ "$TYPE" = "D" ]]
          then
              PREFIX_TEXT="Deleted file "
              FILE_NAME=$FILE
	  elif [[ "$TYPE" = "R" ]]
          then
              PREFIX_TEXT="Renamed file:"
              FILE_NAME=$(echo ${FILE_STRING} | awk '{$1=""; print $0}')
          else
              PREFIX_TEXT=""
              POINT=": "
          fi

          echo -e "\t$index. $PREFIX_TEXT$FILE_NAME$POINT" >> .user/git.log
          let "index+=1"
        done
        unset IFS

        # and then open it in emacs (the alias 'm' should be defined in .aliases)
        emacs $emacs_OPTIONS -f split-window-horizontally .user/git.diff .user/git.log
    # otherwise, print it on the screen
    else
	git diff --cached $@
    fi
}

#----------------------------------------------
dif()
{
    if [ ! -d .user ]; then
        getAnswer "Directory \"`pwd`/.user\" doesn't exist. Would you like to create it?" && mkdir .user
    fi

    if [[ -d svn ]]; then
	svndif $@
    elif [[ $(isGitRepo) -eq 1 ]]; then
	gitdif $@
    else
	echo "Unknown repository type (supported: git, SVN)"
    fi
}


#----------------------------------------------
cmt()
{
    LOG_FILE='.user/git.log'
    
    if [[ -f .git/MERGE_HEAD ]]; then
	echo "Looks like you're about to commit a merge"
	rm ${LOG_FILE}
    fi
    
    if [[ -f $LOG_FILE ]]; then
        echo " "
        NON_REPO_FILES=`st --porcelain | grep '?'`
        if [ ${#NON_REPO_FILES} -ne 0 ]
            then
            echo -e "------------------------------------------" 
            echo -e "Files not added to the repository\n"
            echo -e "${NON_REPO_FILES}" | awk '{print "   "$0}'
            echo -e "\n------------------------------------------"
        fi
        echo "Files changed"
        echo " "
        st  --untracked-files=no

        echo " "
        echo "=================== Begin of log file (" $LOG_FILE ") ========================="
        cat $LOG_FILE

        echo "==================== End of log file (" $LOG_FILE ") =========================="
        echo

        # Format the code
        if [ -f .astyle ]; then
            astyle --recursive '*.C' '*.h' 
        else
            echo "NOT Formatting the code with ASTYLE (no .astyle file found)"
        fi

        getAnswer "Would you like to use the above log message?" && \
	    git commit -F $LOG_FILE
    else
        echo "Could not find log file: $LOG_FILE. Will run 'git commit' instead?"
        git commit
    fi
    
}

#----------------------------------------------
# Function for pulling changes for all repos.
pula()
{
    gitDirs=$(listRepos)
    local alignSize=$(getAlignSize ${gitDirs})

    local msg=""
    for d in ${gitDirs}; do
	cd ${d}
	logFile=.git.pull.log
	git pull > ${logFile} 2>&1
	if [[ $? -ne 0 ]]; then
	    msg="There were problems. See log file ${logFile}"
	elif [[ -n $(grep "Already up-to-date" .git.pull.log) ]]; then
	    msg="no changes"
	else
	    msg="updated ($(pwd)/.git.pull.log)"
	fi
	cd ->/dev/null

	n=$(( alignSize - ${#d} ))
	printf "%s%${n}s: %s\n" "Pulling for ${d}" "" "${msg}"
    done
}


#----------------------------------------------
# Function for pushing changes to all repos.
pizda()
{
    # Changed directories will have a space and some text
    local command=""
    gitDirs=$(st | grep ' ' | cut -d ' ' -f 1)
    local alignSize=$(getAlignSize ${gitDirs})

    echo -e "About to push changes to the following repos:\n"
    st | grep ' ' | awk '{first=$1; $1=""; print first":("$0" )"}' | column -t -s ":"
    ! getAnswer && return 0

    for d in ${gitDirs}; do
	n=$(( alignSize - ${#d} ))
	printf "Pushing for %s%${n}s   : " "${d}" ""
	cd ${d}
	logFile=.git.push.log
	git push > ${logFile} 2>&1
	if [[ $? -ne 0 ]]; then
	    printf "There were problems. See log file ${logFile}\n"
	else
            printf "Done\n"
	fi
	cd ->/dev/null
    done
}



#----------------------------------------------
stall()
{
    local gitDirs=$(listRepos)
    local alignSize=$(getAlignSize ${gitDirs})

    clear
    if [[ ${1} == '-s' ]]; then
	local forNext=1
    fi

    echo "" # Need this for function next
    local lOldPdw=${OLDPWD}
    for d in ${gitDirs}; do
	currMsg=""
	cd ${d}
	local status=$(git status)

	# Check for untracked files
	local hasChanges=0
	if [[ -n $(echo $status | grep "Untracked files") ]]; then
	    currMsg=${currMsg}" has untracked files"
	    hasChanges=$(($hasChanges || 1))
	fi
	if [[ -n $(echo $status | grep "Changes not staged") ]]; then
	    if [[ -n ${currMsg} ]]; then currMsg=${currMsg}" AND"; fi
	    currMsg=${currMsg}" has changes"
	    hasChanges=$(($hasChanges || 1))
	fi

	if [[ -n $(echo $status | grep "Changes to be committed") ]]; then
	    if [[ -n ${currMsg} ]]; then currMsg=${currMsg}" AND"; fi
	    currMsg=${currMsg}" has changes staged for commiting"
	    hasChanges=$(($hasChanges || 1))
	fi
	
	if [[ -n $(echo $status | grep "Your branch is ahead") ]]; then
	    if [[ -n ${currMsg} ]]; then currMsg=${currMsg}" AND"; fi
	    currMsg=${currMsg}" is ahead of origin"
	fi

	if [[ -n $(echo $status | grep "have diverged,") ]]; then
	    if [[ -n ${currMsg} ]]; then currMsg=${currMsg}" AND"; fi
	    currMsg=${currMsg}" has diverged from origin"
	fi

	if [[ $forNext ]] && [[ ${hasChanges} == "1" ]]; then
	    printf "%s:%s\n" ${d} "${currMsg}"
	elif [[ ! $forNext ]]; then
	    n=$(( alignSize - ${#d} ))
	    printf "%s%${n}s%s\n" ${d} "" "${currMsg}"
	fi
	cd ->/dev/null
    done
    OLDPWD=${lOldPdw}
}


#----------------------------------------------
# Options: -c --> go to the next branch that has changes
#
next()
{
    # Need to look at the 2nd line (1st one is empty)
    # When I removed the empty line, cd ${nextDir} just
    #   complained that there is no such director, although
    #   there obviously was. I suspect some non-printing
    #   caracter, but could not find it.
    local nextInfo=$(stall -s | head -n 2 | tail -n 1)
    local nextDir=$(echo ${nextInfo} | cut -d ":"  -f 1)

    if [ -n "${nextDir}" ]; then
	cd ${nextDir}
	echo -e "Repo: ${nextDir}\n"
	st
    else
	echo "No changes found"
    fi
}

#----------------------------------------------
ric()
{
    if [[ $# -lt 2 ]]; then
	echo "Usage: ric from to [filePattern]"
	return 1
    fi
    
    from=$1
    to=$2
    shift 2
    
    myFiles=`allSourceFiles $*`

    IFS=$'\n'
    replace "$from" "$to" -- ${myFiles}
    unset IFS
}

#------------------------------------------
deSCize()
{
    for tag in $*; do
	tagCopy=${tag}
	prefix=''
	if [[ ${tagCopy:0:1} == '_' ]]; then
            prefix='_'
            tagCopy=${tagCopy:1}
	fi
	
	firstLetter=${tagCopy:1:1}
	mainBody=${tagCopy:2}
	
	# For members
	firstLetter=$(lower ${firstLetter})
	
	ric "${tag}" "${prefix}${firstLetter}${mainBody}"
    done
}

#------------------------------------------
deGet()
{
    for tag in $*; do
	
	# Check that it starts with get
	if [[ ${tag:0:3} != 'get' ]]; then
	    echo "tag $tag does not start with 'get'"
	    continue
	fi
	
	tagBody=${tag:4}
	firstLetter=$(lower ${tag:3:1})
	ric "${tag}()" "${firstLetter}${tagBody}()"
    done
}


#----------------------------------------------
lna()
{
    st | grep ? | awk '{print $NF}'
}


# The environment overrides
if [ -f $HOME/.userenv_overrides ]; then
    . $HOME/.userenv_overrides
fi

#----------------------------------------------
# TrueCrypt functions
#----------------------------------------------
mapLoopDevice()
{
    local fileName="${1}"

    # Check that the file is not already mapped
    local deviceName=$(losetup -j "${fileName}" | cut -d ' ' -f 1)
    if [[ -n ${deviceName} ]]; then
	echo "File ${fileName} already mapped as " $(mount | grep ${deviceName} | cut -d ' ' -f 3)
	return 1
    fi
    
    deviceName=$(sudo losetup -f --show "${fileName}")
    echo ${deviceName}
}

#----------------------------------------------
getNextMapping()
{
    local mappingName=""
    # Get the next available trucryptX name in /dev/mapper
    for i in $(seq -w 1 10); do
	mappingName="truecrypt${i}"
	if [[ -n $(ls /dev/mapper | grep ${mappingName}) ]]; then
	    if [[ ${i} == 10 ]]; then
		# All 10 device mapping points are used. Will exit without mapping
		return 1
	    fi
	else
	    break
	fi
    done
    
    echo ${mappingName}
}

#----------------------------------------------
tc()
{
    if [[ $# -lt 1 ]]; then
	echo "Usage: tc [usb|deviceName] mountPoint"
	return 1
    fi

    deviceName=${1}
    mountPoint=${2}

    if [[ $(lower ${deviceName}) == "usb" ]]; then
	echo "Fetching the last usb device mounted"
	deviceName="/dev/"$(dmesg  | grep ': sd' | tail -1 | awk '{print $NF}')
    fi

    ! getAnswer "About to mount device '${deviceName}'. Continue? " && return 1

    # If the device is actually a file on the disk, map it to a loop device
    if [[ -z $(echo ${deviceName} | grep '/dev/sd') ]]; then
	# ! getAnswer "Looks like you're trying to mount a TC file. Continue?" && return 1

	fileName="${deviceName}"	
	deviceName=$(mapLoopDevice "${fileName}")
	echo deviceName=${deviceName}
	if [[ $? -eq 1 ]]; then
	    echo ${deviceName}
	    return 1
	fi
    fi

    # TODO: Check if the device was already mapped
    mappingName=$(getNextMapping)
    if [[ -z ${mappingName} ]]; then
	echo "Could not get device mapping. Exiting."
	return 1
    fi

    # Get the next available mapping point
    if [[ -z ${mountPoint} ]]; then
	baseMountDir="$HOME/truecrypt"
	for i in $(seq -w 1 10); do
	    mountPoint=${baseMountDir}/tc${i}
	    if [[ -n $(mount | grep ${mountPoint}) ]]; then
		echo "Mount point ${mountPoint} is already used"
		if [[ ${i} == 10 ]]; then
		    echo "All 10 mount points are used. Will exit without mapping."
		    return 1
		fi
	    else
		break
	    fi
	done
    fi

    mkdir -p ${mountPoint}
    sudo /sbin/cryptsetup -y -c aes -s 256 -h sha256 create ${mappingName} ${deviceName}
    sudo mount /dev/mapper/${mappingName} ${mountPoint}

    echo "TC Device ${deviceName} mapped as ${mountPoint}"
}

#----------------------------------------------
untc()
{
    if [[ $# -lt 1 ]]; then
	echo "Usage: untc mountPoint"
	return 1
    fi

    mountPoint=$(realpath ${1})

    devName=$(mount | grep " ${mountPoint} " | cut -d ' ' -f 1)
    if [[ -z ${devName} ]]; then
	echo "Mount point ${mountPoint} is not in the mount table. Aborting"
	return 1
    fi
    loopDevice=$(sudo cryptsetup status ${devName} | grep device | awk '{print $NF}')

    if [[ -z ${loopDevice} ]]; then
	echo "Could not find the loop device"
	echo mountPoint=${mountPoint}
	echo devName=${devName}
	echo loopDevice=${loopDevice}

	return 1
    fi

    sudo umount ${mountPoint}
    sudo /sbin/cryptsetup close ${devName}
    sudo losetup -d ${loopDevice}

    if [[ -n $(ls ${mountPoint}) ]]; then
	echo "Mount point ${mountPoint} not empty. Will not remove"
	return 1
    else
	rm -rf ${mountPoint}
    fi
}


#----------------------------------------------
tcnew()
{
    if [[ $# -lt 2 ]]; then
	echo "Usage: tcnew fileName fileSize"
	return 1
    fi

    fileName="${1}"
    fileSize=${2}

    # Check if the file exists
    if [[ -f ${fileName} ]]; then
	echo "File exists: ${fileName}"
	return 1
    fi

    # Create the file
    dd if=/dev/zero of="${fileName}" bs=1 count=0 seek=${fileSize}
    # Map it to a loop device
    deviceName=$(mapLoopDevice "${fileName}")
    if [[ $? -eq 1 ]]; then
	echo ${deviceName}
	return 1
    fi
    
    # Create the volume
    echo "About to create the TrueCrypt volume"
    sudo tcplay -c -d ${deviceName} -a whirlpool -b AES-256-XTS
    
    if [[ $? -ne 0 ]]; then
	echo "Could not create the TrueCrypt volume. Exiting"

	# Delete the mapping
	sudo losetup -d ${deviceName}

	return 1
    fi

    echo deviceName=${deviceName}
    return 1

    # Delete the mapping
    sudo losetup -d ${deviceName}

    # 
    sudo tcplay --map=${mappingName} --device=${deviceName}
    mkfs.ext4 /dev/mapper

    # Mount the volume
    tc ${fileName}
}


mountMarketData()
{
    targetDir="/mnt/MD"
    if [[ -n $(mount | grep " ${targetDir} ") ]]; then
	echo $(mount | grep " ${targetDir} " | awk '{print $1 " is already mounted on " $3". Exiting."}')
	return 0
    fi	
    tc /mnt/MD_crypt/disk.crypt ${targetDir}
}


unmountMarketData()
{
    untc /mnt/MD/
}
