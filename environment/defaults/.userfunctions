# -*- mode: sh -*- #

shopt -s expand_aliases
. ~/.aliases

#----------------------------------------------
# General functions
#----------------------------------------------
getAnswer()
{
    # Pop the question
    local question="${1}"
    if [[ -z ${question} ]]; then
	question="\nWould you like to continue?"
    fi
    question=${question}" [y\\\n]"
    echo -e ${question}

    # Get the answer
    local answer
    read answer
    case $answer in
        y|Y|yes|Yes|YES)
	    return 0
	    ;;
    esac
    return 1
}


log()
{
    LOG_FILE=".user/svn.log"; 
    if [ -f $LOG_FILE ]; then 
        cat $LOG_FILE
    else 
        echo "Could not find log file $LOG_FILE"
    fi
}


#----------------------------------------------
vif()
{
    vi $(f $*)
}


#----------------------------------------------
lower()
{
    echo $* | tr [:upper:] [:lower:]
}

#----------------------------------------------
allSourceFiles()
{
    local myHeaders=".h .hpp"
    local mySources=".C .cpp"
    
    local option=$1    
    
    case ${option} in
        "?")
            echo "Usage: `basename allSourceFiles` [?|-h|-s|pattern]"
            return 0
            ;;
        "-h")
            myExtensions="${myHeaders}"
            ;;
        "-s")
            myExtensions="${mySources}"
            ;;
	
	'')
	    myExtensions="${myHeaders} ${mySources}"
	    ;;
        
        *)
            myExtensions=${@}
            ;;
    esac 
    
    for e in ${myExtensions}; do
	find . -name '*'$e
    done
}

#----------------------------------------------
currentBuildMode()
{
    echo ""
    if [ -f ~/.buildMode ]; then
     ! echo "Current build mode: DEBUG"
    else
       echo "Current build mode: `echo ${SCAMMODE} | tr [:lower:] [:upper:]`"
    fi
    echo ""
}


#----------------------------------------------
setDebug()
{
    if [ $# -ne 1 ]; then
        echo "Usage:  setDebug <on | off>"
        currentBuildMode
        return 1
    fi

    case `echo $1 | tr [:upper:] [:lower:]` in
        on)
            echo -e "export SCAMMODE=debug\nexport STMODE=debug" > ~/.buildMode
	    test -f ~/.makerules_custom && replace -s '#-# CXXFLAGS+=-DDEBUG' 'CXXFLAGS+=-DDEBUG' -- ~/.makerules_custom
        ;;
        off)
            rm -f ~/.buildMode
	    test -f ~/.makerules_custom && replace -s 'CXXFLAGS+=-DDEBUG' '#-# CXXFLAGS+=-DDEBUG' -- ~/.makerules_custom
        ;;
        *)
            echo -e "Unknown option '$1'\n"
            echo "Usage:  setDebug <on | off>"
            return 1
        ;;
    esac

    currentBuildMode

    return 0
}


#----------------------------------------------
isGitRepo()
{
    myDir=$(pwd)
    while [[ ${myDir} != "/" ]]; do
	if [[ -d ${myDir}/.git ]]; then
	    echo 1
	    return
	fi
	myDir=$(dirname ${myDir})
    done
    echo 0
}


#----------------------------------------------
st()
{
    if [[ $(isGitRepo) -eq 1 ]]; then
	git status $@
    else
	stall $@
    fi
}


#----------------------------------------------
svndif()
{
    emacs_OPTIONS="-geometry 232x70"

    # Check for conflicts
    CONFLICTS=`st -q | grep '^C'`
    if [ ${#CONFLICTS} -ne 0 ]
    then
       echo -e "\nConflicts detected. First resolve them before proceeding."
       return 0 
    fi

    # If the directory .user exist ==> write the result to .user/svn.diff
    if [ -d .user ]; then
        svn -q diff > .user/svn.diff

        # Back-up the 'svn.log' file (if it exist)...
        if [ -f .user/svn.log ]
        then
            cp .user/svn.log .user/svn.log.org
        fi

        CHANGED_FILES=`st -q | grep -v '^?' | grep -v '^U' | grep -v '^P'`

        echo "$CHANGED_FILES"

        # ... then write the skeleton in the new one
        echo "Changes:" > .user/svn.log

        IFS=$'\n'
        index=1
        for FILE_STRING in $CHANGED_FILES
          do

          # Split the string into TYPE & FILE
          TYPE=`echo "$FILE_STRING" | awk '{print $1}'`
          FILE=`echo "$FILE_STRING" | awk '{print $NF}'`

          # Check whether it should put the whole path
          if [ -f ".user/.fullpath" ]
              then 
              FILE_NAME=$FILE
          else
              FILE_NAME=`basename "$FILE"`
          fi

          POINT="."
          if [ "$TYPE" = "A" ]
          then
              PREFIX_TEXT="Added file "
              FILE_NAME=$FILE
          elif [ "$TYPE" = "R" ]
          then
              PREFIX_TEXT="Deleted file "
              FILE_NAME=$FILE
          else
              PREFIX_TEXT=""
              POINT=": "
          fi

          echo -e "\t$index. $PREFIX_TEXT$FILE_NAME$POINT" >> .user/svn.log
          let "index+=1"
        done
        unset IFS

        # and then open it in emacs (the alias 'm' should be defined in .aliases)
        m $emacs_OPTIONS -f split-window-horizontally .user/svn.log .user/svn.diff 
    # otherwise, print it on the screen
    else
        svn -q diff 
    fi
}

#----------------------------------------------
gitdif()
{
    emacs_OPTIONS="-geometry 186x50"

    # Check for conflict
    CONFLICTS=`st --porcelain | grep '^C'`
    if [ ${#CONFLICTS} -ne 0 ]
    then
	echo -e "\nConflicts detected. First resolve them before proceeding."
	return 0 
    fi

    if [[ -n $(st | grep 'not staged') ]]; then
	echo -e "\nThere are changes not staged for commit\n"
	st | grep -A 10 'not staged'
	! getAnswer && return 1
    fi

    # If the directory .user exist ==> write the result to .user/svn.diff
    if [ -d .user ]; then
	git diff --cached $@ > .user/git.diff

        # Back-up the 'git.log' file (if it exist)...
        if [ -f .user/git.log ]
        then
            cp .user/git.log .user/git.log.org
        fi

        CHANGED_FILES=`st --porcelain | grep -v '^?' | grep -v '^U' | grep -v '^P'`

        echo "$CHANGED_FILES"

        # ... then write the skeleton in the new one
        echo -e "Summary: \nDetails:" > .user/git.log

        IFS=$'\n'
        index=1
        for FILE_STRING in $CHANGED_FILES
          do

          # Split the string into TYPE & FILE
          TYPE=`echo "$FILE_STRING" | awk '{print $1}'`
          FILE=`echo "$FILE_STRING" | awk '{print $NF}'`

          # Check whether it should put the whole path (defaults to YES)
          if [[ -f ".user/.shortpath" ]]; then 
              FILE_NAME=`basename "$FILE"`
          else
              FILE_NAME=$FILE
          fi

          POINT="."
          if [ "$TYPE" = "A" ]
          then
              PREFIX_TEXT="Added file "
              FILE_NAME=$FILE
          elif [ "$TYPE" = "D" ]
          then
              PREFIX_TEXT="Deleted file "
              FILE_NAME=$FILE
          else
              PREFIX_TEXT=""
              POINT=": "
          fi

          echo -e "\t$index. $PREFIX_TEXT$FILE_NAME$POINT" >> .user/git.log
          let "index+=1"
        done
        unset IFS

        # and then open it in emacs (the alias 'm' should be defined in .aliases)
        emacs $emacs_OPTIONS -f split-window-horizontally .user/git.diff .user/git.log
    # otherwise, print it on the screen
    else
	git diff --cached $@
    fi
}

#----------------------------------------------
dif()
{
    if [ ! -d .user ]; then
        getAnswer "Directory \"`pwd`/.user\" doesn't exist. Would you like to create it?" && mkdir .user
    fi

    if [[ -d svn ]]; then
	svndif $@
    elif [[ $(isGitRepo) -eq 1 ]]; then
	gitdif $@
    else
	echo "Unknown repository type (supported: git, SVN)"
    fi
}


#----------------------------------------------
svncmt()
{
    if [[ ! -f .notrace ]]; then
        toggleTrace off -all
    fi

    LOG_FILE='.user/svn.log'
    CHANGED_FILES=`st -q | grep -v '?'`
    
    if [ -f $LOG_FILE ]
    then
        echo " "
        NON_REPO_FILES=`st -q | grep '?'`
        if [ ${#NON_REPO_FILES} -ne 0 ]
            then
            echo -e "------------------------------------------" 
            echo -e "Files not added to the repository\n"
            echo -e "${NON_REPO_FILES}" | awk '{print "   "$0}'
            echo -e "\n------------------------------------------"
        fi
        echo "Files changed"
        echo " "
        st | awk '{print "   "$0}'

        echo " "
        echo "=================== Begin of log file (" $LOG_FILE ") ========================="
        cat $LOG_FILE

        echo "==================== End of log file (" $LOG_FILE ") =========================="
        echo

        getAnswer "Would you like to use the above log message?" && \
	    svn -q ci -F $LOG_FILE
    else
        echo "Could not find log file: $LOG_FILE. Will run 'svn commit' instead?"
        svn ci
    fi

}


#----------------------------------------------
cmt()
{
    LOG_FILE='.user/git.log'
    
    if [[ -f .git/MERGE_HEAD ]]; then
	echo "Looks like you're about to commit a merge"
	rm ${LOG_FILE}
    fi
    
    if [[ -f $LOG_FILE ]]; then
        echo " "
        NON_REPO_FILES=`st --porcelain | grep '?'`
        if [ ${#NON_REPO_FILES} -ne 0 ]
            then
            echo -e "------------------------------------------" 
            echo -e "Files not added to the repository\n"
            echo -e "${NON_REPO_FILES}" | awk '{print "   "$0}'
            echo -e "\n------------------------------------------"
        fi
        echo "Files changed"
        echo " "
        st  --untracked-files=no

        echo " "
        echo "=================== Begin of log file (" $LOG_FILE ") ========================="
        cat $LOG_FILE

        echo "==================== End of log file (" $LOG_FILE ") =========================="
        echo

        # Format the code
        if [ -f .astyle ]; then
            astyle --recursive '*.C' '*.h' 
        else
            echo "NOT Formatting the code with ASTYLE (no .astyle file found)"
        fi

        getAnswer "Would you like to use the above log message?" && \
	    git commit -F $LOG_FILE
    else
        echo "Could not find log file: $LOG_FILE. Will run 'git commit' instead?"
        git commit
    fi
    
}

# ============================================
rv()
{
    if [ $# -eq 0 ]; then
	! getAnswer "Are you sure you want to revert the whole tree?" && \
	    return 0
	echo "OK! Have it your way!"
    fi

    myDiff=`svn -q diff $* | grep -v '^?'`
    if [ ! -z "${myDiff}" ]; then
        echo "${myDiff}" | patch -s -R -p0
    else
        echo "Nothing to revert"
    fi
}


#----------------------------------------------
# Function for pulling changes for all repos.
# No push-all alternative, since this would be tricky.
pula()
{
    gitDirs=$(find . -maxdepth 5 -type d -name .git)

    for d in ${gitDirs}; do
	d=$(dirname $d)
	echo "Pulling for ${d}"
	cd ${d}
	logFile=.git.pull.log
	git pull > ${logFile} 2>&1
	if [[ $? -ne 0 ]]; then
	    echo "There were problems. See log file ${logFile}"
	fi
	cd ->/dev/null
	echo ""
    done
}

#----------------------------------------------
stall()
{
    local gitDirs=$(find . -maxdepth 5 -type d -name .git)
    clear
    if [[ ${1} == '-s' ]]; then
	local forNext=1
    fi

    test ! ${forNext} && echo ""
    msg=""
    for d in ${gitDirs}; do
	d=$(dirname $d)
	currMsg="\n${d}"
	cd ${d}
	local status=$(git status)

	# Check for untracked files
	local hasChanges=0
	if [[ -n $(echo $status | grep "Untracked files") ]]; then
	    currMsg=${currMsg}":has untracked files"
	    hasChanges=1
	elif [[ -n $(echo $status | grep "Changes not staged") ]]; then
	    currMsg=${currMsg}":has changes"
	    hasChanges=1
	elif [[ -n $(echo $status | grep "Your branch is ahead") ]]; then
	    currMsg=${currMsg}":is ahead of origin"
	    hasChanges=1
	fi

	if [[ $forNext ]] && [[ ${hasChanges} == "1" ]]; then
	    msg=${msg}${currMsg}
	elif [[ ! $forNext ]]; then
	    msg=${msg}${currMsg}
	fi
	cd ->/dev/null
    done

    if [[ ${forNext} ]]; then
	echo -e ${msg}
    else
	echo -e ${msg} | column -t -s ":"
	echo ""
    fi
}


#----------------------------------------------
next()
{
    local nextInfo=$(stall -s | head -2 | tail -1)
    local nextDir=$(echo ${nextInfo} | cut -d ":"  -f 1)
    local nextChanges=$(echo ${nextInfo} | cut -d ":" -f 2)
    if [[ -n ${nextDir} ]]; then
	cd ${nextDir}
	echo -e "Repo: ${nextDir}\n"
	st
    fi
}

#----------------------------------------------
ric()
{
    if [[ $# -lt 2 ]]; then
	echo "Usage: ric from to [filePattern]"
	return 1
    fi
    
    from=$1
    to=$2
    shift 2
    
    myFiles=`allSourceFiles $*`

    IFS=$'\n'
    replace "$from" "$to" -- ${myFiles}
    unset IFS
}

#------------------------------------------
deSCize()
{
    for tag in $*; do
	tagCopy=${tag}
	prefix=''
	if [[ ${tagCopy:0:1} == '_' ]]; then
            prefix='_'
            tagCopy=${tagCopy:1}
	fi
	
	firstLetter=${tagCopy:1:1}
	mainBody=${tagCopy:2}
	
	# For members
	firstLetter=$(lower ${firstLetter})
	
	ric "${tag}" "${prefix}${firstLetter}${mainBody}"
    done
}

#------------------------------------------
deGet()
{
    for tag in $*; do
	
	# Check that it starts with get
	if [[ ${tag:0:3} != 'get' ]]; then
	    echo "tag $tag does not start with 'get'"
	    continue
	fi
	
	tagBody=${tag:4}
	firstLetter=$(lower ${tag:3:1})
	ric "${tag}()" "${firstLetter}${tagBody}()"
    done
}


#----------------------------------------------
lna()
{
    st | grep ? | awk '{print $NF}'
}


# The environment overrides
if [ -f $HOME/.userenv_overrides ]; then
    . $HOME/.userenv_overrides
fi

#----------------------------------------------
# TrueCrypt functions
#----------------------------------------------
mapLoopDevice()
{
    local fileName="${1}"

    # Check that the file is not already mapped
    local deviceName=$(losetup -j "${fileName}" | cut -d ' ' -f 1)
    if [[ -n ${deviceName} ]]; then
	echo "File ${fileName} already mapped as " $(mount | grep ${deviceName} | cut -d ' ' -f 3)
	return 1
    fi
    
    deviceName=$(sudo losetup -f --show "${fileName}")
    echo ${deviceName}
}

#----------------------------------------------
getNextMapping()
{
    local mappingName=""
    # Get the next available trucryptX name in /dev/mapper
    for i in $(seq -w 1 10); do
	mappingName="truecrypt${i}"
	if [[ -n $(ls /dev/mapper | grep ${mappingName}) ]]; then
	    if [[ ${i} == 10 ]]; then
		# All 10 device mapping points are used. Will exit without mapping
		return 1
	    fi
	else
	    break
	fi
    done
    
    echo ${mappingName}
}

#----------------------------------------------
tc()
{
    if [[ $# -lt 1 ]]; then
	echo "Usage: tc [usb|deviceName] mountPoint"
	return 1
    fi

    deviceName=${1}
    mountPoint=${2}

    if [[ $(lower ${deviceName}) == "usb" ]]; then
	echo "Fetching the last usb device mounted"
	deviceName="/dev/"$(dmesg  | grep ': sd' | tail -1 | awk '{print $NF}')
    fi

    ! getAnswer "About to mount device '${deviceName}'. Continue? " && return 1

    # If the device is actually a file on the disk, map it to a loop device
    if [[ -z $(echo ${deviceName} | grep '/dev/sd') ]]; then
	# ! getAnswer "Looks like you're trying to mount a TC file. Continue?" && return 1

	fileName="${deviceName}"	
	deviceName=$(mapLoopDevice "${fileName}")
	echo deviceName=${deviceName}
	if [[ $? -eq 1 ]]; then
	    echo ${deviceName}
	    return 1
	fi
    fi

    # TODO: Check if the device was already mapped
    mappingName=$(getNextMapping)
    if [[ -z ${mappingName} ]]; then
	echo "Could not get device mapping. Exiting."
	return 1
    fi

    # Get the next available mapping point
    if [[ -z ${mountPoint} ]]; then
	baseMountDir="$HOME/truecrypt"
	for i in $(seq -w 1 10); do
	    mountPoint=${baseMountDir}/tc${i}
	    if [[ -n $(mount | grep ${mountPoint}) ]]; then
		echo "Mount point ${mountPoint} is already used"
		if [[ ${i} == 10 ]]; then
		    echo "All 10 mount points are used. Will exit without mapping."
		    return 1
		fi
	    else
		break
	    fi
	done
    fi

    mkdir -p ${mountPoint}
    sudo /sbin/cryptsetup -y -c aes -s 256 -h sha256 create ${mappingName} ${deviceName}
    sudo mount /dev/mapper/${mappingName} ${mountPoint}

    echo "TC Device ${deviceName} mapped as ${mountPoint}"
}

#----------------------------------------------
untc()
{
    if [[ $# -lt 1 ]]; then
	echo "Usage: untc mountPoint"
	return 1
    fi

    mountPoint=$(realpath ${1})

    devName=$(mount | grep " ${mountPoint} " | cut -d ' ' -f 1)
    if [[ -z ${devName} ]]; then
	echo "Mount point ${mountPoint} is not in the mount table. Aborting"
	return 1
    fi
    loopDevice=$(sudo cryptsetup status ${devName} | grep device | awk '{print $NF}')

    if [[ -z ${loopDevice} ]]; then
	echo "Could not find the loop device"
	echo mountPoint=${mountPoint}
	echo devName=${devName}
	echo loopDevice=${loopDevice}

	return 1
    fi

    sudo umount ${mountPoint}
    sudo /sbin/cryptsetup close ${devName}
    sudo losetup -d ${loopDevice}

    if [[ -n $(ls ${mountPoint}) ]]; then
	echo "Mount point ${mountPoint} not empty. Will not remove"
	return 1
    else
	rm -rf ${mountPoint}
    fi
}


#----------------------------------------------
tcnew()
{
    if [[ $# -lt 2 ]]; then
	echo "Usage: tcnew fileName fileSize"
	return 1
    fi

    fileName="${1}"
    fileSize=${2}

    # Check if the file exists
    if [[ -f ${fileName} ]]; then
	echo "File exists: ${fileName}"
	return 1
    fi

    # Create the file
    dd if=/dev/zero of="${fileName}" bs=1 count=0 seek=${fileSize}
    # Map it to a loop device
    deviceName=$(mapLoopDevice "${fileName}")
    if [[ $? -eq 1 ]]; then
	echo ${deviceName}
	return 1
    fi
    
    # Create the volume
    echo "About to create the TrueCrypt volume"
    sudo tcplay -c -d ${deviceName} -a whirlpool -b AES-256-XTS
    
    if [[ $? -ne 0 ]]; then
	echo "Could not create the TrueCrypt volume. Exiting"

	# Delete the mapping
	sudo losetup -d ${deviceName}

	return 1
    fi

    echo deviceName=${deviceName}
    return 1

    # Delete the mapping
    sudo losetup -d ${deviceName}

    # 
    sudo tcplay --map=${mappingName} --device=${deviceName}
    mkfs.ext4 /dev/mapper

    # Mount the volume
    tc ${fileName}
}


mountMarketData()
{
    targetDir="/mnt/MD"
    if [[ -n $(mount | grep " ${targetDir} ") ]]; then
	echo $(mount | grep " ${targetDir} " | awk '{print $1 " is already mounted on " $3". Exiting."}')
	return 0
    fi	
    tc /mnt/MD_crypt/disk.crypt ${targetDir}
}


unmountMarketData()
{
    untc /mnt/MD/
}
